     1                                  ;файл с комментариями к изменениям к листику
     2                                  ;все регистры были изменены на 64-разрядные
     3                                  %include "io64.asm"
     4                              <1>          section .text     ; ������� ����
     5                              <1> IntToStr64: 
     6 00000000 57                  <1>          push   rdi
     7 00000001 53                  <1>          push   rbx
     8 00000002 52                  <1>          push   rdx
     9 00000003 51                  <1>          push   rcx
    10 00000004 56                  <1> 		 push   rsi
    11 00000005 C60600              <1> 		 mov    byte[rsi],0 ; �� ����� �����
    12 00000008 83F800              <1>          cmp    eax,0
    13 0000000B 7D05                <1>          jge    .l1
    14 0000000D F7D8                <1>          neg    eax
    15 0000000F C6062D              <1>          mov    byte[rsi],'-'
    16 00000012 C646060A            <1> .l1      mov    byte[rsi+6],10
    17 00000016 BF05000000          <1>          mov    rdi,5
    18 0000001B 66BB0A00            <1>          mov    bx,10
    19 0000001F 6699                <1> .again:  cwd           ; ��������� ����� �� ��������
    20 00000021 66F7F3              <1>          div    bx     ; ����� ��������� �� 10
    21 00000024 80C230              <1>          add    dl,30h ; �������� �� ������� ��� �����
    22 00000027 88143E              <1>          mov    [rsi+rdi],dl ; ����� ������ � ������
    23 0000002A 48FFCF              <1>          dec    rdi    ; ��������� ��������� ��  
    24                              <1>                        ; ���������� �������
    25 0000002D 6683F800            <1>          cmp    ax, 0  ; ������������� ��� �����?
    26 00000031 75EC                <1>          jne    .again
    27 00000033 B906000000          <1>          mov    rcx, 6
    28 00000038 4829F9              <1>          sub    rcx, rdi ; ����� ����������+����
    29 0000003B 4889C8              <1> 		 mov    rax,rcx
    30 0000003E 48FFC0              <1> 		 inc    rax    ; ����� ����������+OA
    31 00000041 48FFC6              <1>          inc    rsi    ; ���������� ����
    32 00000044 56                  <1> 		 push   rsi
    33 00000045 488D343E            <1>          lea    rsi,[rsi+rdi] ; ������ ����������
    34 00000049 5F                  <1> 		 pop    rdi
    35 0000004A F3A4                <1>          rep movsb
    36 0000004C 5E                  <1>          pop    rsi  
    37 0000004D 59                  <1>          pop    rcx
    38 0000004E 5A                  <1>          pop    rdx
    39 0000004F 5B                  <1>          pop    rbx
    40 00000050 5F                  <1>          pop    rdi
    41 00000051 C3                  <1>          ret
    42                              <1> StrToInt64:
    43 00000052 57                  <1>          push   rdi
    44 00000053 B739                <1>          mov    bh, '9'
    45 00000055 B330                <1>          mov    bl, '0'
    46 00000057 56                  <1>          push   rsi     ; ��������� ����� �������� ������
    47 00000058 803E2D              <1>          cmp    byte[rsi], '-'
    48 0000005B 7503                <1>          jne    .prod
    49 0000005D 48FFC6              <1>          inc    rsi     ; ���������� ����
    50 00000060 FC                  <1> .prod    cld
    51 00000061 6631FF              <1>          xor    di, di  ; �������� ������� �����
    52 00000064 AC                  <1> .cycle:  lodsb          ; ��������� ������ (�����)
    53 00000065 3C0A                <1>          cmp    al, 10  ; ���� 10, �� �� �����
    54 00000067 741F                <1>          je     .Return
    55 00000069 38D8                <1>          cmp    al, bl  ; ���������� � ����� ����
    56 0000006B 722F                <1>          jb     .Error  ; "����" � ������
    57 0000006D 38F8                <1>          cmp    al, bh  ; ���������� � ����� ������ 
    58 0000006F 772B                <1>          ja     .Error  ; "����" � ������
    59 00000071 2C30                <1>          sub    al, 30h ; �������� ����� �� �������
    60 00000073 6698                <1>          cbw            ; ��������� �� �����
    61 00000075 6650                <1>          push   ax      ; ��������� � �����
    62 00000077 66B80A00            <1>          mov    ax, 10  ; ������� 10 � AX
    63 0000007B 66F7E7              <1>          mul    di      ; ��������, ��������� � DX:AX
    64 0000007E 665F                <1>          pop    di      ; � DI � ��������� �����
    65 00000080 6601F8              <1>          add    ax, di
    66 00000083 6689C7              <1>          mov    di, ax  ; � DI � ����������� �����        
    67 00000086 EBDC                <1>          jmp    .cycle
    68 00000088 5E                  <1> .Return: pop    rsi
    69 00000089 BB00000000          <1>          mov    rbx, 0
    70 0000008E 803E2D              <1>          cmp    byte[rsi], '-'
    71 00000091 7503                <1>          jne    .J
    72 00000093 66F7DF              <1>          neg    di
    73 00000096 6689F8              <1> .J       mov    ax, di
    74 00000099 98                  <1>          cwde
    75 0000009A EB0B                <1>          jmp    .R
    76 0000009C 5E                  <1> .Error:  pop    rsi
    77 0000009D B800000000          <1>          mov    rax, 0
    78 000000A2 BB01000000          <1>          mov    rbx, 1
    79 000000A7 5F                  <1> .R       pop    rdi
    80 000000A8 C3                  <1>          ret
     4                                  section .data
     5 00000000 496E70757420737472-         InputMsg dq "Input string: ",10  ; #10 добавила для переноса 
     5 00000009 696E673A2000000A00-
     5 00000012 000000000000       
     6                                      lenInput equ $-InputMsg
     7                                  
     8                                  section .bss
     9 00000000 <res Ah>                    InBuf   resb    10           ; #добавлена переменная буферная 
    10                                      lenIn   equ     $-InBuf
    11 0000000A <res 14h>                   StrInp resb 20
    12                                      lenStr equ $-StrInp
    13                                      ; StrNew times 10 db '' ; #вместо этой переменной используем следующие две
    14 0000001E 727272727272727272-         Stroka2 db "rrrrrrrrrrr",10 ;  #запоминаем первый множитель
    14 00000027 72720A             
    14          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    14          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    15                                  lenStroka2 equ $-Stroka2
    16 0000002A 727272727272727272-         Stroka3 db "rrrrrrrrrrr",10 ; #запоминаем второй множитель
    16 00000033 72720A             
    16          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    16          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    17                                  lenStroka3 equ $-Stroka3
    18 00000036 <res 14h>               lena resw 10 ; #длина строки здесь будет лежать
    19                                  
    20                                  
    21                                  section .text
    22                                  global  _start
    23                                  _start:
    24                                  
    25 000000A9 B801000000                  mov rax, 1
    26 000000AE BF01000000                  mov rdi, 1
    27 000000B3 48BE-                       mov rsi, InputMsg
    27 000000B5 [0000000000000000] 
    28 000000BD BA18000000                  mov rdx, lenInput
    29 000000C2 0F05                        syscall
    30                                  
    31                                      ; read
    32 000000C4 B800000000                  mov rax, 0  
    33 000000C9 BF00000000                  mov rdi, 0      
    34 000000CE 48BE-                       mov rsi, StrInp  
    34 000000D0 [0A00000000000000] 
    35 000000D8 BA14000000                  mov rdx, lenStr  
    36 000000DD 0F05                        syscall        
    37                                  
    38                                  
    39                                  ;основная часть
    40                                  
    41                                  
    42                                  ;подсчет длины введенной строки до кода Enter добавлено и добавлен подсчет количества чисел
    43 000000DF 488D3C25[0A000000]      lea rdi,[StrInp] ;загрузили строку 
    44 000000E7 B914000000              mov rcx,lenStr ;сюда длину введенной строки
    45 000000EC B00A                    mov al,0Ah ;ищем код Enter
    46 000000EE F2AE                    repne scasb ;сканируем до него
    47 000000F0 B814000000              mov rax,20 ;сюда длину выделенную загрузили
    48 000000F5 4829C8                  sub rax,rcx ;находим разницу
    49 000000F8 4889C1                  mov rcx,rax ;поменяли регистры местами
    50 000000FB C681[09000000]20        mov byte[rcx+StrInp-1],' ' ;добавила в конец пробел, потому что считать количество чисел по ним буду
    51 00000102 48FFC9                  dec rcx ; #уменьшила длину строки на 1, чтобы положить в переменную длину строки 
    52 00000105 48890C25[36000000]      mov [lena],rcx ; #запомнила переменную
    53 0000010D 48FFC1                  inc rcx ; #увеличила обратно, чтобы посчитать количество чисел
    54                                  
    55                                  
    56 00000110 BA00000000                  mov edx,0
    57 00000115 BB00000000                  mov ebx,0
    58                                  
    59                                  cycl:
    60 0000011A 488DB2[0A000000]            lea rsi, [StrInp + rdx]
    61                                      ; mov al,' ' ; #оптимизировала сравнение в одну строку
    62                                      ; cmp [StrInp + edx], al ; #оптимизировала сравнение в одну строку
    63 00000121 80BA[0A000000]20            cmp byte[StrInp + rdx], ' '  ; #вот строка 
    64 00000128 7402                        je probel
    65 0000012A EB05                        jmp next
    66                                  
    67                                  probel: 
    68 0000012C 48FFC3                      inc rbx ;в rbx количество слов теперь
    69 0000012F EB00                        jmp next
    70                                  next: 
    71 00000131 48FFC2                      inc rdx
    72 00000134 E2E4                        loop cycl
    73                                  
    74                                  
    75                                   
    76                                  ;стараемся посчитать произведение
    77                                  
    78 00000136 4989D9                      mov r9, rbx ; #заменила на r9 rcx, rax на rbx
    79                                      ; mov ebx, lenStr ; #вместо этой переменной используется [lena]
    80 00000139 BA00000000                  mov rdx,0 ; #очистила регистры перед началом работы цикла
    81 0000013E BB00000000                  mov rbx,0 ; #очистила регистры
    82                                  
    83                                  cycl1:
    84                                      ;mov al, ' ' ; #оптимизировала сравнение в одну строку
    85 00000143 67488DB2[0A000000]          lea rsi,[StrInp+edx]
    86                                      ;cmp [StrInp+edx], al ; #оптимизировала сравнение в одну строку
    87 0000014B 6780BA[0A000000]21          cmp byte[StrInp + edx], 0x21 ; сравнила с пробелом и меньше, так как в начале исходной строки и в конце нет пробелов
    88                                  
    89 00000153 7E16                        jle probel1 ; #переход если меньше, а не просто эквивалентно пробелу
    90 00000155 48FFC2                      inc rdx
    91                                  
    92 00000158 B901000000                  mov rcx, 1 ; #добавила, так как нужно указать сколько символов копирую в строку
    93 0000015D 488DBB[1E000000]            lea rdi, [Stroka2 + rbx] ; #заменила регистр смещения и имя переменной, в которую записываю
    94 00000164 F3A4                        repe movsb
    95                                  
    96 00000166 48FFC3                      inc rbx ; #увеличила регистр смещения в строке, куда копировать
    97 00000169 EBD8                        jmp cycl1
    98                                  
    99                                  probel1:
   100                                  
   101 0000016B 48FFC2                      inc rdx
   102                                      ; mov esi, [StrNew+edx] ; #не нужно, было перенесено выше в коде и изменено имя переменной, регистр смещения и на rdi rsi
   103 0000016E C683[1E000000]0A            mov byte[Stroka2+rbx],10 ; #нужно добавить \n для работы подпрограммы io64
   104                                  
   105 00000175 52                          push rdx ; #поместила в стэк, так как после выполнения подпрограммы регистр изменяется, для корректной работы подпрограммы, а также он будет использоваться далее в программе
   106 00000176 48BE-                       mov rsi, Stroka2 ; #нужно поместить в rsi для корректной работы подпрограммы
   106 00000178 [1E00000000000000] 
   107 00000180 E8CDFEFFFF                  call StrToInt64
   108                                  
   109 00000185 4989C0                      mov r8, rax ; #было ниже в коде, сейчас сохранила сразу в этот регистр, так как rax будет использован
   110                                      ; jmp cycl2 ; #не нужен переход, так как выполняем последовательно
   111                                  
   112 00000188 BA00000000                  mov rdx,0 ; #очищаю регистр, будет использован для подсчета цифр в числе
   113 0000018D 488B1C25[36000000]          mov rbx, [lena] ; #поместила в регистр смещение, раньше вместо этого было mov ebx, lenStr 
   114                                  
   115                                  cycl2:
   116                                  
   117 00000195 48FFCB                      dec rbx ; #перенесла строку вверх, так как при переходе по метке probel2 не происходило увеличение смещения
   118                                      ; mov eax, ' ' ; #оптимизировала сравнение в одну строку
   119 00000198 488DB3[0A000000]            lea rsi, [StrInp+rbx] ;добавила смещение в конец исходной строки сразу rbx
   120                                      ; add edi, ebx ; #не нужно, так как сразу добавила смещение
   121                                      ; cmp edi, eax ; #оптимизировала сравнение в одну строку
   122 0000019F 48891C25[36000000]          mov [lena], rbx ; #пересохранила в переменную длину смещения, чтобы при выполнении повторном смещение было не в конец исходной строки, а на число, которое еще не считали
   123 000001A7 803E21                      cmp byte[rsi], 0x21 ; #сравнила с пробелом и меньше, так как в начале исходной строки и в конце нет пробелов 
   124 000001AA 7E05                        jle probel2 ; #переход если меньше, а не просто эквивалентно пробелу
   125                                  
   126 000001AC 48FFC2                      inc rdx ; #здесь теперь лежит количество цифр в числе
   127                                  
   128                                      ; jmp cycl2 ;убрано, так как повтор был
   129                                      ; lea edi, [StrNew+ebx] ; #копировать числа буду теперь после того как найду пробел
   130                                      ; repe movsb ; #копирую ниже 
   131 000001AF EBE4                        jmp cycl2
   132                                  
   133                                  
   134                                  probel2:
   135                                   
   136                                      ; mov r8,rax ; #эта строчка переехала выше
   137 000001B1 4889D1                      mov rcx, rdx ; #поместила в счетчик количество цифр в числе
   138 000001B4 B800000000                  mov rax,0 ; #обнулила начало смещения для Stroka3
   139 000001B9 48FFC6                      inc rsi ; #инкрементировала, чтобы не указывало на пробел
   140 000001BC 67488DB8[2A000000]          lea rdi, [Stroka3+eax] ; #поменяла имя и регистр теперь eax, и загрузка в rdi вместо rsi
   141 000001C4 F3A4                        repe movsb
   142 000001C6 67C682[2A000000]0A          mov byte[Stroka3+edx],10 ; #нужно добавить \n для работы подпрограммы io64
   143                                  
   144 000001CE 48BE-                       mov rsi, Stroka3 ; #нужно было не адрес переносить, скобки не нужны, также поменяла имя переменной
   144 000001D0 [2A00000000000000] 
   145 000001D8 E875FEFFFF                  call StrToInt64
   146 000001DD 49F7E8                      imul r8
   147                                      ; dec ebx ;убрано, так как этот регистр был нужен для смещения по строке, но теперь иначе идет смещение
   148 000001E0 48BE-                       mov rsi, InBuf ; #для перевода числа в строку в rsi нужно поместить переменную, нужно для корректной работы подпрограммы
   148 000001E2 [0000000000000000] 
   149 000001EA E811FEFFFF                  call IntToStr64
   150                                      ; push rdx ; #не нужно, так как в стэке лежит уже необходимое значение
   151 000001EF 4889C2                      mov rdx, rax
   152 000001F2 B801000000                  mov rax, 1    ; системная функция 1 (write)
   153 000001F7 BF01000000                  mov rdi, 1    ; дескриптор файла stdout=1
   154 000001FC 0F05                        syscall
   155 000001FE 5A                          pop rdx
   156 000001FF BB00000000                  mov rbx,0 ; #очистила регистр, чтобы при втором и дальнейших выполнениях цикла смещение в новой строке было с 0
   157                                  
   158 00000204 49FFC9                      dec r9 ; #заменила этими строками loop
   159 00000207 4983F900                    cmp r9, 0 ; #заменила этими строками loop
   160                                      ; loop cycl1 ; #слишком далеко уходим для loop
   161 0000020B 0F8F32FFFFFF                jg cycl1 ; #если больше нуля, то не по всем числам прошли в строке, значит повторяем
   162                                  
   163                                  
   164                                  exit:
   165 00000211 4831FF                      xor rdi, rdi
   166 00000214 B83C000000                  mov rax, 60
   167 00000219 0F05                        syscall
