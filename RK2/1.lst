     1                                  ;файл с комментариями к изменениям к файлу old.asm
     2                                  ;все регистры были изменены на 64-разрядные
     3                                  %include "io64.asm"
     4                              <1>          section .text     ; ������� ����
     5                              <1> IntToStr64: 
     6 00000000 57                  <1>          push   rdi
     7 00000001 53                  <1>          push   rbx
     8 00000002 52                  <1>          push   rdx
     9 00000003 51                  <1>          push   rcx
    10 00000004 56                  <1> 		 push   rsi
    11 00000005 C60600              <1> 		 mov    byte[rsi],0 ; �� ����� �����
    12 00000008 83F800              <1>          cmp    eax,0
    13 0000000B 7D05                <1>          jge    .l1
    14 0000000D F7D8                <1>          neg    eax
    15 0000000F C6062D              <1>          mov    byte[rsi],'-'
    16 00000012 C646060A            <1> .l1      mov    byte[rsi+6],10
    17 00000016 BF05000000          <1>          mov    rdi,5
    18 0000001B 66BB0A00            <1>          mov    bx,10
    19 0000001F 6699                <1> .again:  cwd           ; ��������� ����� �� ��������
    20 00000021 66F7F3              <1>          div    bx     ; ����� ��������� �� 10
    21 00000024 80C230              <1>          add    dl,30h ; �������� �� ������� ��� �����
    22 00000027 88143E              <1>          mov    [rsi+rdi],dl ; ����� ������ � ������
    23 0000002A 48FFCF              <1>          dec    rdi    ; ��������� ��������� ��  
    24                              <1>                        ; ���������� �������
    25 0000002D 6683F800            <1>          cmp    ax, 0  ; ������������� ��� �����?
    26 00000031 75EC                <1>          jne    .again
    27 00000033 B906000000          <1>          mov    rcx, 6
    28 00000038 4829F9              <1>          sub    rcx, rdi ; ����� ����������+����
    29 0000003B 4889C8              <1> 		 mov    rax,rcx
    30 0000003E 48FFC0              <1> 		 inc    rax    ; ����� ����������+OA
    31 00000041 48FFC6              <1>          inc    rsi    ; ���������� ����
    32 00000044 56                  <1> 		 push   rsi
    33 00000045 488D343E            <1>          lea    rsi,[rsi+rdi] ; ������ ����������
    34 00000049 5F                  <1> 		 pop    rdi
    35 0000004A F3A4                <1>          rep movsb
    36 0000004C 5E                  <1>          pop    rsi  
    37 0000004D 59                  <1>          pop    rcx
    38 0000004E 5A                  <1>          pop    rdx
    39 0000004F 5B                  <1>          pop    rbx
    40 00000050 5F                  <1>          pop    rdi
    41 00000051 C3                  <1>          ret
    42                              <1> StrToInt64:
    43 00000052 57                  <1>          push   rdi
    44 00000053 B739                <1>          mov    bh, '9'
    45 00000055 B330                <1>          mov    bl, '0'
    46 00000057 56                  <1>          push   rsi     ; ��������� ����� �������� ������
    47 00000058 803E2D              <1>          cmp    byte[rsi], '-'
    48 0000005B 7503                <1>          jne    .prod
    49 0000005D 48FFC6              <1>          inc    rsi     ; ���������� ����
    50 00000060 FC                  <1> .prod    cld
    51 00000061 6631FF              <1>          xor    di, di  ; �������� ������� �����
    52 00000064 AC                  <1> .cycle:  lodsb          ; ��������� ������ (�����)
    53 00000065 3C0A                <1>          cmp    al, 10  ; ���� 10, �� �� �����
    54 00000067 741F                <1>          je     .Return
    55 00000069 38D8                <1>          cmp    al, bl  ; ���������� � ����� ����
    56 0000006B 722F                <1>          jb     .Error  ; "����" � ������
    57 0000006D 38F8                <1>          cmp    al, bh  ; ���������� � ����� ������ 
    58 0000006F 772B                <1>          ja     .Error  ; "����" � ������
    59 00000071 2C30                <1>          sub    al, 30h ; �������� ����� �� �������
    60 00000073 6698                <1>          cbw            ; ��������� �� �����
    61 00000075 6650                <1>          push   ax      ; ��������� � �����
    62 00000077 66B80A00            <1>          mov    ax, 10  ; ������� 10 � AX
    63 0000007B 66F7E7              <1>          mul    di      ; ��������, ��������� � DX:AX
    64 0000007E 665F                <1>          pop    di      ; � DI � ��������� �����
    65 00000080 6601F8              <1>          add    ax, di
    66 00000083 6689C7              <1>          mov    di, ax  ; � DI � ����������� �����        
    67 00000086 EBDC                <1>          jmp    .cycle
    68 00000088 5E                  <1> .Return: pop    rsi
    69 00000089 BB00000000          <1>          mov    rbx, 0
    70 0000008E 803E2D              <1>          cmp    byte[rsi], '-'
    71 00000091 7503                <1>          jne    .J
    72 00000093 66F7DF              <1>          neg    di
    73 00000096 6689F8              <1> .J       mov    ax, di
    74 00000099 98                  <1>          cwde
    75 0000009A EB0B                <1>          jmp    .R
    76 0000009C 5E                  <1> .Error:  pop    rsi
    77 0000009D B800000000          <1>          mov    rax, 0
    78 000000A2 BB01000000          <1>          mov    rbx, 1
    79 000000A7 5F                  <1> .R       pop    rdi
    80 000000A8 C3                  <1>          ret
     4                                  section .data
     5 00000000 496E70757420737472-         InputMsg dq "Input string: ",10  
     5 00000009 696E673A2000000A00-
     5 00000012 000000000000       
     6                                      lenInput equ $-InputMsg
     7                                      ; Max dw 0
     8                                  section .bss
     9 00000000 <res Ah>                    InBuf   resb    10            
    10                                      lenIn   equ     $-InBuf
    11 0000000A <res 1Eh>                   StrInp resb 30
    12                                      lenStr equ $-StrInp
    13                                      ; StrNew times 10 db '' ; #вместо этой переменной используем следующие две
    14 00000028 727272727272727272-         Stroka2 db "rrrrrrrrrrr",10 ;  #переменная, чтобы запомнить первый множитель
    14 00000031 72720A             
    14          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    14          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    15                                  lenStroka2 equ $-Stroka2
    16 00000034 727272727272727272-         Stroka3 db "rrrrrrrrrrr",10 ; #запоминаем второй множитель
    16 0000003D 72720A             
    16          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    16          ******************       warning: attempt to initialize memory in BSS section `.bss': ignored [-w+other]
    17                                  lenStroka3 equ $-Stroka3
    18 00000040 <res 14h>               lena resw 10 ; #длина строки здесь будет лежать
    19                                  
    20                                  
    21                                  section .text
    22                                  global  _start
    23                                  _start:
    24                                  
    25 000000A9 B801000000                  mov rax, 1
    26 000000AE BF01000000                  mov rdi, 1
    27 000000B3 48BE-                       mov rsi, InputMsg
    27 000000B5 [0000000000000000] 
    28 000000BD BA18000000                  mov rdx, lenInput
    29 000000C2 0F05                        syscall
    30                                  
    31                                      ; read
    32 000000C4 B800000000                  mov rax, 0  
    33 000000C9 BF00000000                  mov rdi, 0      
    34 000000CE 48BE-                       mov rsi, StrInp  
    34 000000D0 [0A00000000000000] 
    35 000000D8 BA1E000000                  mov rdx, lenStr  
    36 000000DD 0F05                        syscall        
    37                                  
    38                                  
    39                                  ;основная часть
    40                                  
    41                                  
    42                                  ;подсчет длины введенной строки до кода Enter
    43 000000DF 488D3C25[0A000000]      lea rdi,[StrInp] 
    44 000000E7 B91E000000              mov rcx,lenStr
    45 000000EC B00A                    mov al,0Ah
    46 000000EE F2AE                    repne scasb
    47 000000F0 B81E000000              mov rax,30
    48 000000F5 4829C8                  sub rax,rcx
    49 000000F8 4889C1                  mov rcx,rax
    50 000000FB C681[09000000]20        mov byte[rcx+StrInp-1],' ' 
    51 00000102 48FFC9                  dec rcx ; #уменьшила длину строки на 1, чтобы положить в переменную длину строки 
    52 00000105 48890C25[40000000]      mov [lena],rcx ; #запомнила переменную
    53 0000010D 48FFC1                  inc rcx ; #увеличила обратно, чтобы посчитать количество чисел
    54                                  
    55                                  
    56 00000110 BA00000000                  mov edx,0
    57 00000115 BB00000000                  mov ebx,0
    58                                  
    59                                  cycl:
    60 0000011A 488DB2[0A000000]            lea rsi, [StrInp + rdx]
    61                                      ; mov al,' ' ; #оптимизировала сравнение в одну строку
    62                                      ; cmp [StrInp + edx], al ; #оптимизировала сравнение в одну строку
    63 00000121 80BA[0A000000]20            cmp byte[StrInp + rdx], ' '  ; #вот строка 
    64 00000128 7402                        je probel
    65 0000012A EB05                        jmp next
    66                                  
    67                                  probel: 
    68 0000012C 48FFC3                      inc rbx
    69 0000012F EB00                        jmp next
    70                                  next: 
    71 00000131 48FFC2                      inc rdx
    72 00000134 E2E4                        loop cycl
    73                                  
    74                                  ; #вывод количества чисел не нужен по заданию
    75                                      ; mov rax, rbx 
    76                                  
    77                                      ; call IntToStr64
    78                                  
    79                                      ; mov rdx,rax
    80                                      ; mov rax,1
    81                                      ; mov rdi,1
    82                                      ; syscall
    83                                  ; #конец вывода
    84                                   
    85                                  ;стараемся посчитать произведение
    86                                  
    87 00000136 4989D9                      mov r9, rbx ; #заменила на r9
    88                                      ; mov ebx, lenStr ; #вместо этой переменной используется [lena]
    89 00000139 BA00000000                  mov rdx,0 ; #очистила регистры перед началом работы цикла
    90 0000013E BB00000000                  mov rbx,0 ; #очистила регистры
    91                                  
    92                                  cycl1:
    93                                      ;mov al, ' ' ; #оптимизировала сравнение в одну строку
    94 00000143 67488DB2[0A000000]          lea rsi,[StrInp+edx]
    95                                      ;cmp [StrInp+edx], al ; #оптимизировала сравнение в одну строку
    96 0000014B 6780BA[0A000000]21          cmp byte[StrInp + edx], 0x21 ; сравнила с пробелом и меньше, так как в начале исходной строки и в конце нет пробелов
    97                                  
    98 00000153 7E16                        jle probel1 ; #переход если меньше, а не просто эквивалентно пробелу
    99 00000155 48FFC2                      inc rdx
   100                                  
   101 00000158 B901000000                  mov rcx, 1 ; #добавила, так как нужно указать сколько символов копирую в строку
   102 0000015D 488DBB[28000000]            lea rdi, [Stroka2 + rbx] ; #заменила регистр смещения и имя переменной, в которую записываю
   103 00000164 F3A4                        repe movsb
   104                                  
   105 00000166 48FFC3                      inc rbx ; #увеличила регистр смещения в строке, куда копировать
   106 00000169 EBD8                        jmp cycl1
   107                                  
   108                                  probel1:
   109                                  
   110 0000016B 48FFC2                      inc rdx
   111                                      ; mov esi, [StrNew] ; #не нужно, так как используем другие переменные
   112 0000016E C683[28000000]0A            mov byte[Stroka2+rbx],10 ; #нужно добавить \n для работы подпрограммы io64
   113                                  
   114 00000175 52                          push rdx ; #поместила в стэк, так как после выполнения подпрограммы регистр изменяется, для корректной работы подпрограммы, а также он будет использоваться далее в программе
   115 00000176 48BE-                       mov rsi, Stroka2 ; #нужно поместить в rsi для корректной работы подпрограммы
   115 00000178 [2800000000000000] 
   116 00000180 E8CDFEFFFF                  call StrToInt64
   117                                  
   118 00000185 4989C0                      mov r8, rax ; #было ниже в коде, сейчас сохранила сразу в этот регистр, так как rax будет использован
   119                                      ; jmp cycl2 ; #не нужен переход, так как выполняем последовательно
   120                                  
   121 00000188 BA00000000                  mov rdx,0 ; #очищаю регистр, будет использован для подсчета цифр в числе
   122 0000018D 488B1C25[40000000]          mov rbx, [lena] ; #поместила в регистр смещение, раньше вместо этого было mov ebx, lenStr 
   123                                  
   124                                  cycl2:
   125                                  
   126 00000195 48FFCB                      dec rbx ; #перенесла строку вверх, так как при переходе по метке probel2 не происходило увеличение смещения
   127                                      ; mov eax, ' ' ; #оптимизировала сравнение в одну строку
   128 00000198 488DB3[0A000000]            lea rsi, [StrInp+rbx] ;добавила смещение в конец исходной строки сразу
   129                                      ; add edi, ebx ; #не нужно, так как сразу добавила смещение
   130                                      ; cmp edi, eax ; #оптимизировала сравнение в одну строку
   131 0000019F 48891C25[40000000]          mov [lena], rbx ; #пересохранила в переменную длину смещения, чтобы при выполнении повторном смещение было не в конец исходной строки, а на число, которое еще не считали
   132 000001A7 803E21                      cmp byte[rsi], 0x21 ; #сравнила с пробелом и меньше, так как в начале исходной строки и в конце нет пробелов 
   133 000001AA 7E05                        jle probel2 ; #переход если меньше, а не просто эквивалентно пробелу
   134                                  
   135 000001AC 48FFC2                      inc rdx ; #здесь теперь лежит количество цифр в числе
   136                                  
   137                                  
   138                                      ; lea edi, [StrNew+ebx] ; #копировать числа буду теперь после того как найду пробел
   139                                      ; repe movsb ; #копирую ниже 
   140 000001AF EBE4                        jmp cycl2
   141                                  
   142                                  probel2:
   143                                      ; dec ebx ; #эти 2 строчки переехали выше
   144                                      ; mov r8,rax
   145 000001B1 4889D1                      mov rcx, rdx ; #поместила в счетчик количество цифр в числе
   146 000001B4 B800000000                  mov rax,0 ; #обнулила начало смещения для Stroka3
   147 000001B9 48FFC6                      inc rsi ; #инкрементировала, чтобы не указывало на пробел
   148 000001BC 67488DB8[34000000]          lea rdi, [Stroka3+eax] ; #поменяла имя и регистр теперь eax
   149 000001C4 F3A4                        repe movsb
   150 000001C6 67C682[34000000]0A          mov byte[Stroka3+edx],10 ; #нужно добавить \n для работы подпрограммы io64
   151                                  
   152 000001CE 48BE-                       mov rsi, Stroka3 ; #нужно было не адрес переносить, скобки не нужны, также поменяла имя переменной
   152 000001D0 [3400000000000000] 
   153 000001D8 E875FEFFFF                  call StrToInt64
   154 000001DD 49F7E8                      imul r8
   155 000001E0 48BE-                       mov rsi, InBuf ; #для перевода числа в строку в rsi нужно поместить переменную, нужно для корректной работы подпрограммы
   155 000001E2 [0000000000000000] 
   156 000001EA E811FEFFFF                  call IntToStr64
   157                                      ; push rdx ; #не нужно, так как в стэке лежит уже необходимое значение
   158 000001EF 4889C2                      mov rdx, rax
   159 000001F2 B801000000                  mov rax, 1    ; системная функция 1 (write)
   160 000001F7 BF01000000                  mov rdi, 1    ; дескриптор файла stdout=1
   161 000001FC 0F05                        syscall
   162 000001FE 5A                          pop rdx
   163 000001FF BB00000000                  mov rbx,0 ; #очистила регистр, чтобы при втором и дальнейших выполнениях цикла смещение в новой строке было с 0
   164                                  
   165 00000204 49FFC9                      dec r9 ; #заменила этими строками loop
   166 00000207 4983F900                    cmp r9, 0 ; #заменила этими строками loop
   167                                      ; loop cycl1 ; #слишком далеко уходим для loop
   168 0000020B 0F8F32FFFFFF                jg cycl1 ; #если больше нуля, то не по всем числам прошли в строке, значит повторяем
   169                                  
   170                                  
   171                                  exit:
   172 00000211 4831FF                      xor rdi, rdi
   173 00000214 B83C000000                  mov rax, 60
   174 00000219 0F05                        syscall
